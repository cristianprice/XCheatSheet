#Valgrind

##Callgrind

[Official Manual](http://valgrind.org/docs/manual/cl-manual.html)

Callgrind generates a **call-graph**, showing caller-callee relationships, counting functions calls and counting Ir (instruction references) (by default). It can also simulate cache misses and branch predictions, by setting command line flags.

```bash
valgrind --tool=callgrind ./myapp
```

It will generate a profile file like *callgrind.out.4990*. The session number may change.

###Profiling only selected piece of code

Insert the macros in your source code:

```cpp
#include  <valgrind/callgrind.h>

//code before

CALLGRIND_START_INSTRUMENTATION;
//the meat
//...
CALLGRIND_STOP_INSTRUMENTATION;
CALLGRIND_DUMP_STATS;

//code after
```

On the command line, start profiling with

```bash
 valgrind --tool=callgrind --instr-atstart=no ./myapp
```

###Visualizing profile with *kcachegrind*

**Kcachegrind** is a GUI that display the profile generated by valgrind.
```bash
kcachegrind callgrind.out.4990
```

###Invoke debugger when error occurs
```
valgrind --db-attach=yes ./myapp
```
This will launch **gdb** when valgrind encounters an error.

##Memcheck

**memcheck** is the default tool used by Valgrind. It is intended to idendify memory related problems, which mainly include:

+ Memory leak (e.g., `new` without `free`)
+ Illegal access (e.g., "one past the end" access)

```bash
valgrind --leak-check=yes  --read-var-info=yes ./myapp
```

For memory leak, it shows where the leaked memory is allocated. For illegal access, it may report if the accessed address is near some legal address space.

The ` --read-var-info ` option can provide more detailed information about illegal access location.

```bash
valgrind --tool=memcheck --leak-check=yes --track-origins=yes --trace-children=yes --db-attach=yes --log-file="valgrind.log" pg_ctl -D ./data start 
```
